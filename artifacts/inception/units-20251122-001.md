# Units: Windows Notification System

**Session ID**: 20251122-001
**Phase**: Inception - Unit Decomposition
**Created**: 2025-11-22
**Intent Reference**: intent-20251122-001.md

---

## Overview

This document decomposes the Windows Notification System Intent into 6 independently deliverable Units. Each Unit represents a coherent set of functionality that can be developed, tested, and integrated incrementally.

**Total Estimated Effort**: 8-15 bolts (8-15 days)

---

## Unit 1: CoreNotificationService

**Description**: Implements the core Windows toast notification engine using Windows.UI.Notifications APIs. This Unit provides the fundamental capability to display native Windows 10/11 toast notifications with title, message, and duration control. Integrates with Windows Action Center for notification history.

**Components**:
- `INotificationService` interface - Abstract notification contract
- `WindowsToastNotificationService` class - Windows toast implementation
- `NotificationRequest` record - Data model for notification parameters
- `NotificationResult` record - Result/status information
- `ToastNotificationBuilder` class - Fluent API for building toast XML

**Dependencies**:
- None (foundational Unit)
- External: Microsoft.Toolkit.Uwp.Notifications (7.1.3)

**Acceptance Criteria**:
- [ ] Display Windows toast notification with title and message
- [ ] Support configurable duration (default 5 seconds, range 1-30 seconds)
- [ ] Toast appears in Windows Action Center after display
- [ ] Notification service initializes in < 50ms
- [ ] Handle notification service errors gracefully (return error codes)
- [ ] Support silent notifications (no sound)
- [ ] Unit tests achieve 80%+ coverage
- [ ] Works on Windows 10 (1809+) and Windows 11

**Complexity**: Medium
**Estimated Bolts**: 2-3

**Technical Notes**:
- Must handle Windows notification service disabled scenarios
- XML toast template generation for Windows.UI.Notifications
- COM interop for Windows notification APIs
- Thread safety for concurrent notification requests

---

## Unit 2: CommandLineInterface

**Description**: Implements robust command-line argument parsing using System.CommandLine. Provides user-friendly help system, validates all input parameters, and returns appropriate exit codes for PowerShell integration. Serves as the entry point for the console application.

**Components**:
- `Program` class - Application entry point
- `CommandLineOptions` record - Strongly-typed CLI options
- `CommandLineParser` class - Argument parsing and validation
- `HelpFormatter` class - Custom help text generation
- `ExitCodes` enum - Standardized exit codes (0=success, 1=error, 2=invalid args)

**Dependencies**:
- Unit 1 (CoreNotificationService) - Calls notification service
- External: System.CommandLine (2.0.0-beta)

**Acceptance Criteria**:
- [ ] Parse --title/-t, --message/-m, --duration/-d, --sound/-s, --help/-h arguments
- [ ] Display comprehensive help text with examples
- [ ] Validate required arguments (title and message)
- [ ] Return exit code 0 on success, non-zero on error
- [ ] Support PowerShell piped input for message text
- [ ] Execute and exit in < 100ms after sending notification
- [ ] Handle invalid arguments with clear error messages
- [ ] Support both long-form (--title) and short-form (-t) arguments

**Complexity**: Low
**Estimated Bolts**: 1-2

**Technical Notes**:
- System.CommandLine provides robust parsing and help generation
- Must exit immediately after notification dispatch (non-blocking)
- Consider stdin input for long messages or piped scenarios
- Detailed error messages for troubleshooting

---

## Unit 3: AudioNotificationSupport

**Description**: Adds audio feedback to notifications by playing system sounds for different notification types (success, error, warning, info). Uses Windows built-in sounds via System.Media.SoundPlayer or NAudio for reliable cross-version compatibility.

**Components**:
- `IAudioService` interface - Audio playback abstraction
- `WindowsAudioService` class - Windows system sound implementation
- `NotificationType` enum - Success, Error, Warning, Info, Silent
- `SoundMapper` class - Maps notification types to Windows system sounds
- Audio playback integration with NotificationService

**Dependencies**:
- Unit 1 (CoreNotificationService) - Extends notification service
- External: NAudio (2.2.1) or System.Media.SoundPlayer

**Acceptance Criteria**:
- [ ] Play distinct sounds for success, error, warning, info notification types
- [ ] Use Windows built-in system sounds (no custom audio files)
- [ ] Support --sound/-s CLI argument with type selection
- [ ] Support silent mode (--sound none or omitted)
- [ ] Audio playback does not block notification display
- [ ] Handle audio device unavailable scenarios gracefully
- [ ] Sound plays within 50ms of notification display
- [ ] Unit tests verify sound selection logic

**Complexity**: Low
**Estimated Bolts**: 1

**Technical Notes**:
- System.Media.SoundPlayer for simple built-in sounds
- Consider NAudio for more advanced scenarios
- Async audio playback to avoid blocking
- Fallback if audio device unavailable

---

## Unit 4: CustomWindowUI

**Description**: Implements optional WPF-based custom notification windows for interactive scenarios requiring user acknowledgment or button selection. Supports configurable buttons (OK, Cancel, Yes/No, custom) and returns user choice as exit code for PowerShell script integration.

**Components**:
- `NotificationWindow` class - WPF window implementation
- `NotificationWindowViewModel` class - MVVM view model
- `ButtonConfiguration` record - Button definitions (text, exit code)
- `WindowStyleService` class - Applies Windows 11/10 modern styling
- `IWindowNotificationService` interface - Window-based notification contract

**Dependencies**:
- Unit 1 (CoreNotificationService) - Shares core notification models
- External: WPF framework (.NET 10)

**Acceptance Criteria**:
- [ ] Display WPF window with title, message, and configurable buttons
- [ ] Support --type window CLI argument to trigger window mode
- [ ] Support --buttons argument for custom button sets (e.g., "Yes,No,Cancel")
- [ ] Return button selection as exit code (0-based index or predefined codes)
- [ ] Window appears centered on primary monitor
- [ ] Window has modern Windows 11 styling (rounded corners, system theme)
- [ ] Window blocks until user dismissal (modal behavior)
- [ ] Support keyboard shortcuts (Enter=default, Esc=cancel)
- [ ] Unit tests verify button configuration and result codes

**Complexity**: Medium
**Estimated Bolts**: 2-3

**Technical Notes**:
- WPF required for custom window support
- MVVM pattern for testability
- System theme integration for native look
- Consider Fluent Design elements for Windows 11
- Modal window blocks until user action

---

## Unit 5: PowerShellModuleIntegration

**Description**: Creates a PowerShell module (.psm1) with helper functions that wrap the NotifyUser.exe executable, providing idiomatic PowerShell cmdlets for common notification scenarios. Simplifies usage and improves developer experience for PowerShell automation scripts.

**Components**:
- `NotifyUser.psm1` - PowerShell module file
- `Show-Notification` - General notification function
- `Show-SuccessNotification` - Success notification helper
- `Show-ErrorNotification` - Error notification helper
- `Show-WarningNotification` - Warning notification helper
- `Show-InfoNotification` - Info notification helper
- Module manifest (.psd1) for metadata

**Dependencies**:
- Unit 2 (CommandLineInterface) - Calls NotifyUser.exe
- Requires NotifyUser.exe in same directory or PATH

**Acceptance Criteria**:
- [ ] Provide Show-Notification cmdlet with full parameter support
- [ ] Provide shorthand cmdlets for success/error/warning/info
- [ ] Support PowerShell pipeline input for message parameter
- [ ] Include comprehensive cmdlet help (Get-Help Show-Notification)
- [ ] Support -WhatIf and -Confirm common parameters where applicable
- [ ] Module loads without errors in PowerShell 5.1 and PowerShell 7+
- [ ] Include usage examples in module documentation
- [ ] Auto-locate NotifyUser.exe in module directory

**Complexity**: Low
**Estimated Bolts**: 1

**Technical Notes**:
- Pure PowerShell implementation (no C#)
- Wrapper functions around NotifyUser.exe
- Use Start-Process or direct invocation
- Proper error handling and parameter validation
- Consider module auto-loading in PowerShell profile

---

## Unit 6: BuildAndPackaging

**Description**: Implements build configuration, single-file executable packaging, and deployment preparation. Produces a self-contained, compressed Windows x64 executable with no external dependencies. Includes testing infrastructure and CI/CD preparation.

**Components**:
- `.csproj` configuration - Single-file, self-contained, trimmed build
- Build scripts (PowerShell) - Automated build and packaging
- `README.md` - User documentation with examples
- `CHANGELOG.md` - Version history
- Unit test projects - xUnit test infrastructure
- GitHub Actions workflow (optional) - CI/CD pipeline

**Dependencies**:
- All Units 1-5 (integration and packaging)
- .NET 10 SDK

**Acceptance Criteria**:
- [ ] Produce single-file self-contained executable (win-x64)
- [ ] EXE size < 30 MB after compression and trimming
- [ ] No external dependencies required (no .NET runtime installation)
- [ ] Build script automates: restore, build, test, publish, package
- [ ] All unit tests pass (70%+ coverage target)
- [ ] Zero compilation warnings
- [ ] README includes installation, usage, examples, troubleshooting
- [ ] Executable runs on clean Windows 10/11 without .NET runtime
- [ ] Executable startup time < 100ms on modern hardware

**Complexity**: Medium
**Estimated Bolts**: 2

**Technical Notes**:
- .NET 10 PublishSingleFile and SelfContained properties
- PublishTrimmed and PublishReadyToRun for size/performance
- Consider compression tools for additional size reduction
- Test on clean Windows VM without .NET runtime
- IL trimming warnings must be addressed

---

## Unit Dependency Graph

```
Unit 1: CoreNotificationService (foundational)
    |
    +-- Unit 2: CommandLineInterface (depends on Unit 1)
    |       |
    |       +-- Unit 5: PowerShellModuleIntegration (depends on Unit 2)
    |
    +-- Unit 3: AudioNotificationSupport (depends on Unit 1)
    |
    +-- Unit 4: CustomWindowUI (depends on Unit 1)

Unit 6: BuildAndPackaging (depends on all Units 1-5)
```

**Recommended Implementation Order**:
1. Unit 1 (CoreNotificationService) - Foundation
2. Unit 2 (CommandLineInterface) - Entry point
3. Unit 3 (AudioNotificationSupport) - Audio enhancement
4. Unit 6 (BuildAndPackaging) - First testable executable
5. Unit 4 (CustomWindowUI) - Optional interactive feature
6. Unit 5 (PowerShellModuleIntegration) - Developer experience

---

## Risk Assessment

### High Priority Risks
1. **Windows API Compatibility** (Unit 1)
   - Risk: Toast notification APIs differ between Windows 10/11 versions
   - Mitigation: Use stable Microsoft.Toolkit library, test on both OS versions

2. **Self-Contained EXE Size** (Unit 6)
   - Risk: Single-file EXE exceeds 30 MB target
   - Mitigation: Aggressive trimming, test trimming compatibility, exclude WPF if necessary

3. **WPF Bloat** (Unit 4)
   - Risk: WPF adds significant size to EXE
   - Mitigation: Make Unit 4 optional, consider separate executable for window mode

### Medium Priority Risks
1. **Antivirus False Positives** (Unit 6)
   - Risk: Self-contained EXEs flagged by antivirus
   - Mitigation: Code signing, clear documentation, avoid obfuscation

2. **PowerShell Execution Policy** (Unit 5)
   - Risk: Strict policies block .psm1 module loading
   - Mitigation: Document unblock process, provide alternatives

---

## Testing Strategy

### Unit Testing
- xUnit framework for all C# code
- Mock INotificationService for CLI testing
- Test all notification types, durations, error scenarios
- Target: 70%+ code coverage (Intent requirement: 70%)

### Integration Testing
- Test NotifyUser.exe from PowerShell scripts
- Verify toast display on Windows 10 and Windows 11
- Test all CLI argument combinations
- Verify exit codes in automation scenarios

### Manual Testing
- Visual verification of toast notifications
- Audio playback testing for all notification types
- WPF window display and button interaction
- PowerShell module cmdlet testing

### Performance Testing
- Measure EXE startup time (target: < 100ms)
- Measure notification display latency (target: < 100ms)
- Monitor memory usage (target: < 50 MB peak)
- Verify EXE size (target: < 30 MB)

---

## Success Metrics (Aligned with Intent)

### Functional Success
- All Intent success criteria met across Units
- Core notification (Units 1-3) fully functional
- CLI integration (Unit 2, 5) meets PowerShell automation needs
- Optional UI (Unit 4) provides interactive capability

### Quality Success
- Unit test coverage ≥ 70% (Intent requirement)
- Zero compilation warnings (Intent requirement)
- All tests pass on Windows 10 and 11 (Intent requirement)

### Performance Success
- EXE size < 30 MB (Intent requirement)
- Startup time < 100ms (Intent requirement)
- Memory usage < 50 MB peak (Intent requirement)

---

## Next Steps

1. **Bolt Planning**: `/ai-dlc:plan-bolt`
   - Create detailed implementation plans for Units 1-2 (foundational)
   - Break down each Unit into 1-3 day bolts

2. **Domain Modeling**: `/ai-dlc:domain-model`
   - Design object model for NotificationRequest, NotificationService, etc.
   - Define interfaces and abstractions

3. **Code Generation**: `/ai-dlc:generate-code`
   - Start with Unit 1 (CoreNotificationService)
   - Generate C# code for toast notifications

---

**Units Status**: ✅ Complete
**Ready for**: Bolt Planning (`/ai-dlc:plan-bolt`)
